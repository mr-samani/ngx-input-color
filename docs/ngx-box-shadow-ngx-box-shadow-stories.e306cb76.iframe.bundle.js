(self.webpackChunkngx_input_color=self.webpackChunkngx_input_color||[]).push([[368],{"./projects/ngx-input-color/src/lib/ngx-box-shadow/ngx-box-shadow.component.scss?ngResource":(module,__unused_webpack_exports,__webpack_require__)=>{var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/noSourceMaps.js"),___CSS_LOADER_EXPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/api.js")(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);___CSS_LOADER_EXPORT___.push([module.id,'.ngx-box-shadow-container {\n  width: 180px;\n  max-width: 100%;\n  border: 1px #bfbfbf solid;\n  border-radius: 15px;\n  background-color: white;\n  overflow: hidden;\n  box-shadow: 0px 0px 20px 0px rgba(0, 0, 0, 0.31);\n  direction: ltr;\n  padding: 12px;\n}\n.ngx-box-shadow-container * {\n  box-sizing: border-box;\n}\n\n.pad-container {\n  position: relative;\n  width: 100px;\n  height: 100px;\n  border: 1px #545454 solid;\n  box-sizing: border-box;\n  direction: ltr;\n  border-radius: 3px;\n}\n.pad-container::after, .pad-container::before {\n  content: "";\n  position: absolute;\n  border: 1px rgba(145, 145, 145, 0.4117647059) solid;\n}\n.pad-container::after {\n  width: 100%;\n  top: calc(50% - 1px);\n  left: 0px;\n}\n.pad-container::before {\n  height: 100%;\n  top: 0px;\n  left: calc(50% - 1px);\n}\n.pad-container .thumb {\n  box-shadow: inset 0 0 0px 2px #fff;\n  width: 15px;\n  height: 15px;\n  display: block;\n  border-radius: 10px;\n  position: absolute;\n  cursor: pointer;\n  background: blue;\n}\n\n.ngx-settings .ngx-row {\n  display: flex;\n  align-items: flex-end;\n  justify-content: space-between;\n}\n.ngx-settings input:not([type=range]) {\n  width: 46px;\n  border: none;\n  border: 1px solid rgba(145, 145, 145, 0.4117647059);\n  padding: 2px 4px;\n  border-radius: 5px;\n  background-color: transparent;\n  color: #000;\n  font-size: 14px;\n  font-weight: 500;\n  text-align: center;\n  direction: ltr;\n}\n.ngx-settings input:not([type=range]):focus {\n  outline: none;\n  border: 1px solid #09218d;\n}\n.ngx-settings input[type=range] {\n  width: 100%;\n}',""]),module.exports=___CSS_LOADER_EXPORT___.toString()},"./projects/storybook/src/ngx-box-shadow/ngx-box-shadow.stories.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{Default:()=>Default,__namedExportsOrder:()=>__namedExportsOrder,default:()=>ngx_box_shadow_stories});var dist=__webpack_require__("./node_modules/@storybook/angular/dist/index.mjs"),common=__webpack_require__("./node_modules/@angular/common/fesm2022/common.mjs"),fesm2022_forms=__webpack_require__("./node_modules/@angular/forms/fesm2022/forms.mjs"),tslib_es6=__webpack_require__("./node_modules/tslib/tslib.es6.mjs");var ngx_box_shadow_componentngResource=__webpack_require__("./projects/ngx-input-color/src/lib/ngx-box-shadow/ngx-box-shadow.component.scss?ngResource"),ngx_box_shadow_componentngResource_default=__webpack_require__.n(ngx_box_shadow_componentngResource),core=__webpack_require__("./node_modules/@angular/core/fesm2022/core.mjs"),get_offset_position=__webpack_require__("./projects/ngx-input-color/src/utils/get-offset-position.ts");function parseBoxShadowToPx(shadow,contextPx=16){if(!shadow?.trim())return null;let inset=!1;(shadow=shadow.trim()).startsWith("inset")&&(inset=!0,shadow=shadow.slice(5).trim());const colorMatch=shadow.match(/(#(?:[a-f0-9]{3}|[a-f0-9]{6}|[a-f0-9]{4}|[a-f0-9]{8})\b|rgb\(\d{1,3},\s*\d{1,3},\s*\d{1,3}\)|rgba\(\d{1,3},\s*\d{1,3},\s*\d{1,3},\s*\d*(?:\.\d+)?\)|hsl\(\s*\d+,\s*\d*(?:\.\d+)?%,\s*\d*(?:\.\d+)?%\)|hsla\(\d+,\s*[\d.]+%,\s*[\d.]+%,\s*\d*(?:\.\d+)?\))/gi);let color="black";colorMatch&&(color=colorMatch[0],shadow=shadow.replace(color,"").trim());const values=[...shadow.matchAll(/(-?\d*\.?\d+)([a-zA-Z%]*)/g)].map(([_,num,unit])=>((value,unit)=>{switch(unit.toLowerCase()){case"px":case"":default:return value;case"em":case"rem":return value*contextPx;case"%":return value/100*contextPx;case"pt":return 1.333*value}})(parseFloat(num),unit)),[offsetX,offsetY,blur,spread]=values;return{inset,offsetX:offsetX??0,offsetY:offsetY??0,blurRadius:blur??0,spreadRadius:spread??0,color}}var ngx_input_color_module=__webpack_require__("./projects/ngx-input-color/src/ngx-input-color.module.ts");let NgxBoxShadowComponent=class NgxBoxShadowComponent{set setTheme(val){this.theme=val&&"auto"!=val?val:window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light"}constructor(cd){this.cd=cd,this.theme="light",this.maxRange=25,this.change=new core.EventEmitter,this.isDisabled=!1,this.isDragging=!1,this.value={x:0,y:0},this.x=0,this.y=0,this.blur=0,this.spread=0,this.color="black",this.line={x1:0,y1:0,x2:0,y2:0},this.center={x:0,y:0},this._onChange=value=>{},this._onTouched=()=>{},this._onValidateChange=()=>{}}ngOnInit(){}ngAfterViewInit(){this.updateRects()}ngOnDestroy(){}registerOnChange(fn){this._onChange=fn}registerOnTouched(fn){this._onTouched=fn}setDisabledState(disabled){this.isDisabled=disabled}registerOnValidatorChange(fn){this._onValidateChange=fn}validate(control){return null}writeValue(value){if(this.resetPosition(),value){const boxShadow=parseBoxShadowToPx(value);console.log(boxShadow),boxShadow&&(this.value={x:boxShadow.offsetX,y:boxShadow.offsetY},this.blur=boxShadow.blurRadius,this.spread=boxShadow.spreadRadius,this.color=boxShadow.color,this.convertValueToPosition(boxShadow.offsetX,boxShadow.offsetY))}}dragStart(ev){ev.stopPropagation(),ev.preventDefault(),this.isDragging=!0,this.updatePosition(ev),this.updateRects()}updateRects(){this.padRect=this.pad.nativeElement.getBoundingClientRect(),this.thumbRect=this.thumb.nativeElement.getBoundingClientRect()}resetPosition(){this.padRect&&this.thumbRect||this.updateRects(),this.center={x:this.padRect.width/2,y:this.padRect.height/2},this.x=this.center.x-this.thumbRect.width/2,this.y=this.center.y-this.thumbRect.height/2,this.line={x1:this.center.x,y1:this.center.y,x2:this.center.x,y2:this.center.y},this.cd.detectChanges()}onResize(){this.writeValue(this.value)}onDrag(ev){this.isDragging&&this.updatePosition(ev)}updatePosition(ev){if(!this.isDragging)return;this.padRect&&this.thumbRect||this.updateRects();const position=(0,get_offset_position.$)(ev,this.pad.nativeElement),padRec=this.padRect,thumbRec=this.thumbRect,minX=thumbRec.width/2,maxX=padRec.width-thumbRec.width/2,minY=thumbRec.height/2,maxY=padRec.height-thumbRec.height/2,clampedX=Math.max(minX,Math.min(position.x,maxX)),clampedY=Math.max(minY,Math.min(position.y,maxY));this.x=clampedX-thumbRec.width/2,this.y=clampedY-thumbRec.height/2,this.line={x1:this.center.x,y1:this.center.y,x2:this.x+thumbRec.width/2,y2:this.y+thumbRec.height/2},this.setValueByPosition(thumbRec,padRec)}onDragEnd(ev){this.isDragging=!1}setValueByPosition(thumbRec,padRec){const padCenterX=(padRec.width-thumbRec.width)/2,padCenterY=(padRec.height-thumbRec.height)/2,dx=this.x-padCenterX,dy=this.y-padCenterY,halfRangeX=(padRec.width-thumbRec.width)/2,halfRangeY=(padRec.height-thumbRec.height)/2;let valueX=dx/halfRangeX*this.maxRange,valueY=dy/halfRangeY*this.maxRange;valueX=Math.round(valueX),valueY=Math.round(valueY),valueX=Math.min(Math.max(valueX,-this.maxRange),this.maxRange),valueY=Math.min(Math.max(valueY,-this.maxRange),this.maxRange);const newValue={x:valueX,y:valueY};this.value&&this.value.x===valueX&&this.value.y===valueY||(this.value=newValue,this.onChangeData())}onChangeValue(){this.convertValueToPosition(this.value.x,this.value.y),this.onChangeData()}convertValueToPosition(offsetX,offsetY){this.padRect&&this.thumbRect||this.updateRects();let proposedX=this.padRect.width/2+offsetX-this.thumbRect.width/2,proposedY=this.padRect.height/2+offsetY-this.thumbRect.height/2;const maxX=this.padRect.width-this.thumbRect.width,maxY=this.padRect.height-this.thumbRect.height;this.x=Math.min(Math.max(proposedX,0),maxX),this.y=Math.min(Math.max(proposedY,0),maxY),this.line={x1:this.center.x,y1:this.center.y,x2:this.x+this.thumbRect.width/2,y2:this.y+this.thumbRect.height/2},this.cd.detectChanges()}onChangeData(){const boxShadow=function stringifyBoxShadow(obj){const{inset,offsetX,offsetY,blurRadius,spreadRadius,color}=obj;return[inset?"inset":"",`${offsetX}px`,`${offsetY}px`,`${blurRadius}px`,`${spreadRadius}px`,color].filter(Boolean).join(" ").trim()}({inset:!1,offsetX:this.value.x,offsetY:this.value.y,blurRadius:this.blur,spreadRadius:this.spread,color:this.color});this._onChange(boxShadow),this.change.emit(boxShadow)}stopPropagation(ev){ev.stopPropagation()}static{this.ctorParameters=()=>[{type:core.ChangeDetectorRef}]}static{this.propDecorators={setTheme:[{type:core.Input,args:["theme"]}],maxRange:[{type:core.Input}],change:[{type:core.Output}],pad:[{type:core.ViewChild,args:["pad",{static:!0}]}],thumb:[{type:core.ViewChild,args:["thumb",{static:!0}]}],onResize:[{type:core.HostListener,args:["window:resize",["$event"]]}],onDrag:[{type:core.HostListener,args:["document:mousemove",["$event"]]},{type:core.HostListener,args:["document:touchmove",["$event"]]}],onDragEnd:[{type:core.HostListener,args:["document:mouseup",["$event"]]},{type:core.HostListener,args:["document:touchend",["$event"]]}]}}};NgxBoxShadowComponent=(0,tslib_es6.Cg)([(0,core.Component)({standalone:!0,selector:"ngx-box-shadow",template:'<div class="ngx-box-shadow-container" (click)="stopPropagation($event)">\r\n  <div class="pad-container" #pad>\r\n    <svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">\r\n      <line\r\n        [attr.x1]="line.x1"\r\n        [attr.y1]="line.y1"\r\n        [attr.x2]="line.x2"\r\n        [attr.y2]="line.y2"\r\n        stroke="blue"\r\n        stroke-width="2" />\r\n    </svg>\r\n    <div\r\n      class="thumb"\r\n      #thumb\r\n      [style.left.px]="x"\r\n      [style.top.px]="y"\r\n      (mousedown)="dragStart($event)"\r\n      (touchstart)="dragStart($event)"></div>\r\n  </div>\r\n\r\n  <div class="ngx-settings">\r\n    <div class="ngx-setting-item">\r\n      <div class="ngx-row">\r\n        <span>Offset X</span>\r\n        <input type="number" id="offsetX" [(ngModel)]="value.x" (ngModelChange)="onChangeValue()" />\r\n      </div>\r\n      <input\r\n        type="range"\r\n        id="offsetX"\r\n        [(ngModel)]="value.x"\r\n        (ngModelChange)="onChangeValue()"\r\n        step="1"\r\n        [min]="-maxRange"\r\n        [max]="maxRange" />\r\n    </div>\r\n    <div class="ngx-setting-item">\r\n      <div class="ngx-row">\r\n        <span>Offset Y</span>\r\n        <input type="number" id="offsetY" [(ngModel)]="value.y" (ngModelChange)="onChangeValue()" />\r\n      </div>\r\n      <input\r\n        type="range"\r\n        id="offsetY"\r\n        [(ngModel)]="value.y"\r\n        (ngModelChange)="onChangeValue()"\r\n        step="1"\r\n        [min]="-maxRange"\r\n        [max]="maxRange" />\r\n    </div>\r\n    <div class="ngx-setting-item">\r\n      <div class="ngx-row">\r\n        <span>Blur</span>\r\n        <input type="number" id="blur" [(ngModel)]="blur" (ngModelChange)="onChangeValue()" />\r\n      </div>\r\n      <input type="range" id="blur" [(ngModel)]="blur" (ngModelChange)="onChangeValue()" step="1" />\r\n    </div>\r\n    <div class="ngx-setting-item">\r\n      <div class="ngx-row">\r\n        <span>Spread</span>\r\n        <input type="number" id="spread" [(ngModel)]="spread" (ngModelChange)="onChangeValue()" />\r\n      </div>\r\n      <input type="range" id="spread" [(ngModel)]="spread" (ngModelChange)="onChangeValue()" step="1" />\r\n    </div>\r\n    <div class="ngx-setting-item">\r\n      <div class="ngx-row">\r\n        <span>color</span>\r\n        <input\r\n          type="text"\r\n          readonly\r\n          id="color"\r\n          [(ngModel)]="color"\r\n          ngxInputColor\r\n          [simpleMode]="true"\r\n          (ngModelChange)="onChangeData()"\r\n          autocomplete="off" />\r\n      </div>\r\n    </div>\r\n  </div>\r\n\r\n</div>\r\n',changeDetection:core.ChangeDetectionStrategy.OnPush,providers:[{provide:fesm2022_forms.kq,useExisting:(0,core.forwardRef)(()=>NgxBoxShadowComponent),multi:!0},{provide:fesm2022_forms.cz,multi:!0,useExisting:NgxBoxShadowComponent}],imports:[common.MD,fesm2022_forms.YN,ngx_input_color_module.T],styles:[ngx_box_shadow_componentngResource_default()]})],NgxBoxShadowComponent);let NgxInputBoxShadowDirective=class NgxInputBoxShadowDirective{constructor(_doc,el,renderer,viewContainerRef){this._doc=_doc,this.el=el,this.renderer=renderer,this.viewContainerRef=viewContainerRef,this.setInputBackground=!0,this.isDisabled=!1,this.value="",this._onChange=value=>{},this._onTouched=()=>{},this._onValidateChange=()=>{}}onClick(ev){ev.stopPropagation(),ev.preventDefault(),this.toggleColorPicker()}registerOnChange(fn){this._onChange=fn}registerOnTouched(fn){this._onTouched=fn}setDisabledState(disabled){this.isDisabled=disabled}registerOnValidatorChange(fn){this._onValidateChange=fn}validate(control){return null}ngOnDestroy(){this.destroyPicker()}writeValue(value){this.value=value}toggleColorPicker(){if(this.pickerComponentRef)return void this.destroyPicker();this.pickerComponentRef=this.viewContainerRef.createComponent(NgxBoxShadowComponent);this.pickerComponentRef.instance.writeValue(this.value),this.backdrop=this.renderer.createElement("div"),this.backdrop&&(this.backdrop.style.cssText="\n          background: #5e5e5e1e;\n          position: fixed;\n          top: 0;\n          left: 0;\n          right: 0;\n          bottom: 0;\n          overflow: auto;\n          transition: all 300ms;\n          z-index: 1000;\n        ",this.backdrop.onclick=()=>this.destroyPicker()),this.pickerEl=this.pickerComponentRef.hostView.rootNodes[0],this.renderer.appendChild(this.backdrop,this.pickerEl),this.renderer.appendChild(this._doc.body,this.backdrop),this.setPosition()}setPosition(){setTimeout(()=>{if(!this.pickerEl||!this.pickerComponentRef)return;const hostRect=this.el.nativeElement.getBoundingClientRect(),pickerEl=this.pickerEl;this.renderer.setStyle(pickerEl,"position","absolute"),this.renderer.setStyle(pickerEl,"z-index","9999"),this._doc.body.appendChild(pickerEl);const pickerRect=pickerEl.getBoundingClientRect();let left=hostRect.left+hostRect.width/2-pickerRect.width/2,top=hostRect.bottom;left+pickerRect.width>window.innerWidth&&(left=window.innerWidth-pickerRect.width-8),left<8&&(left=8),top+pickerRect.height>window.innerHeight&&(top=hostRect.top-pickerRect.height),top<8&&(top=8),this.renderer.setStyle(pickerEl,"top",`${top}px`),this.renderer.setStyle(pickerEl,"left",`${left}px`)})}destroyPicker(){this.pickerComponentRef&&(this.pickerComponentRef.destroy(),this.pickerComponentRef=void 0),this.backdrop&&this.backdrop.parentNode&&(this.renderer.removeChild(this._doc.body,this.backdrop),this.backdrop=void 0),this.pickerEl=void 0}static{this.ctorParameters=()=>[{type:Document,decorators:[{type:core.Inject,args:[common.qQ]}]},{type:core.ElementRef},{type:core.Renderer2},{type:core.ViewContainerRef}]}static{this.propDecorators={setInputBackground:[{type:core.Input}],onClick:[{type:core.HostListener,args:["click",["$event"]]}],setPosition:[{type:core.HostListener,args:["window:resize",["$event"]]}]}}};NgxInputBoxShadowDirective=(0,tslib_es6.Cg)([(0,core.Directive)({selector:"[ngxInputBoxShadow]",providers:[{provide:fesm2022_forms.kq,useExisting:(0,core.forwardRef)(()=>NgxInputBoxShadowDirective),multi:!0},{provide:fesm2022_forms.cz,multi:!0,useExisting:NgxInputBoxShadowDirective}]})],NgxInputBoxShadowDirective);let NgxInputBoxShadowModule=class NgxInputBoxShadowModule{};NgxInputBoxShadowModule=(0,tslib_es6.Cg)([(0,core.NgModule)({declarations:[NgxInputBoxShadowDirective],imports:[common.MD,fesm2022_forms.YN,NgxBoxShadowComponent],exports:[NgxBoxShadowComponent,NgxInputBoxShadowDirective],providers:[]})],NgxInputBoxShadowModule);const ngx_box_shadow_stories={title:"Demo/NgxBoxShadow",component:NgxBoxShadowComponent,tags:["autodocs"],argTypes:{},args:{},decorators:[(0,dist.Iz)({imports:[common.MD,fesm2022_forms.YN,NgxInputBoxShadowModule]})]},Default={render:args=>({props:{...args,model:"0 24px 46px 0 rgba(0,0,0,.04)"},template:'\n      <ngx-box-shadow\n        [(ngModel)]="model">\n      </ngx-box-shadow>\n      <p>{{model}}</p>\n    '})},__namedExportsOrder=["Default"];Default.parameters={...Default.parameters,docs:{...Default.parameters?.docs,source:{originalSource:"{\n  render: args => ({\n    props: {\n      ...args,\n      model: '0 24px 46px 0 rgba(0,0,0,.04)'\n    },\n    template: `\n      <ngx-box-shadow\n        [(ngModel)]=\"model\">\n      </ngx-box-shadow>\n      <p>{{model}}</p>\n    `\n  })\n}",...Default.parameters?.docs?.source}}}}}]);